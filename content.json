{"meta":{"title":"Hexo","subtitle":"","description":"朝闻道，夕可死矣","author":"John Doe","url":"https://zhaoshengmu.top"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-08-08T06:51:29.159Z","comments":true,"path":"about/index.html","permalink":"https://zhaoshengmu.top/about/index.html","excerpt":"","text":"[朝生暮の少年] 与&nbsp; 朝生暮 （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-08-10T00:39:18.917Z","comments":true,"path":"bangumi/index.html","permalink":"https://zhaoshengmu.top/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2022-08-05T14:13:03.859Z","comments":false,"path":"client/index.html","permalink":"https://zhaoshengmu.top/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2022-08-10T15:13:48.000Z","updated":"2022-08-11T08:03:14.306Z","comments":true,"path":"comment/index.html","permalink":"https://zhaoshengmu.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2022-08-08T07:16:23.119Z","comments":true,"path":"donate/index.html","permalink":"https://zhaoshengmu.top/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-08-08T07:16:56.070Z","comments":false,"path":"lab/index.html","permalink":"https://zhaoshengmu.top/lab/index.html","excerpt":"","text":"sakura主题暂时不知道说什么好~","keywords":"Lab实验室"},{"title":"music","date":"2022-12-20T15:14:28.000Z","updated":"2022-08-09T14:46:20.827Z","comments":true,"path":"music/index.html","permalink":"https://zhaoshengmu.top/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2022-08-09T15:11:06.000Z","updated":"2022-08-08T07:23:10.086Z","comments":true,"path":"links/index.html","permalink":"https://zhaoshengmu.top/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-08T22:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://zhaoshengmu.top/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-08T22:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://zhaoshengmu.top/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2022-08-04T14:53:25.000Z","updated":"2022-08-08T06:51:29.147Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://zhaoshengmu.top/theme-sakura/index.html","excerpt":"","text":"本博客修改自主题Sakura，感谢原作者hojun","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-08T22:13:18.000Z","comments":false,"path":"video/index.html","permalink":"https://zhaoshengmu.top/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"算法刷题","slug":"算法 7b1a8214-a20f-468d-b7c0-ca4a94df6fd6 (2)","date":"2022-08-18T13:16:01.000Z","updated":"2022-08-18T14:51:43.173Z","comments":true,"path":"2022/08/18/算法 7b1a8214-a20f-468d-b7c0-ca4a94df6fd6 (2)/","link":"","permalink":"https://zhaoshengmu.top/2022/08/18/算法 7b1a8214-a20f-468d-b7c0-ca4a94df6fd6 (2)/","excerpt":"","text":"突然觉得博客可以用来写题，感觉还能鞭策自己，不过我感觉我真不一定能坚持下去，tmd这算法看半天看不懂一道，看懂了第二天就忘，太离谱了。不管怎么，先试试吧。 本算法的第一题呢就想用接雨水这道题，因为这道题给我留下了很深的印象，当初第一次看到这道题的时候感觉我大概能想出来一种解法，没想到LeetCode给了四种解法。然后那天晚上刷知乎，刚好碰到我关注的一个人更新了，很巧的是他那篇文章里面也提到了了接雨水的这道题，所以我刚才找了半天把当初看到的他的那篇文章挂在下面了。https://www.zhihu.com/question/525911720/answer/2426321379 接雨水 最大子序和力扣题目链接 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例:输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 个人看法：这道题放在第二道是因为当初第一眼看它的时候很是蒙圈，然后当时看的解法，那个解法用的贪心算法，当时那感觉，如同被打通了任督二脉，那时候还没学到贪心算法，只觉得这算法是真心强，当然现在看来这个算法算是很简单的算法了，但是在当时的我看来这个特别神奇，我做不出的算法题有很多，解法巧妙的那也很多，但是很少有一道题像这样在当时给我以那么大的心灵震撼，所以把它放在了第二题位置。 暴力解法暴力解法的思路，第一层for 就是设置起始位置，第二层for循环遍历数组寻找最大值 时间复杂度：O(n^2) 空间复杂度：O(1) class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int result = INT32_MIN; int count = 0; for (int i = 0; i &lt; nums.size(); i++) { // 设置起始位置 count = 0; for (int j = i; j &lt; nums.size(); j++) { // 每次从起始位置i开始遍历寻找最大值 count += nums[j]; result = count &gt; result ? count : result; } } return result; } }; 以上暴力的解法C++勉强可以过，其他语言就不确定了。 贪心解法贪心贪的是哪里呢？ 如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！ 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。 全局最优：选取最大“连续和” 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。 从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。 这相当于是暴力解法中的不断调整最大子序和区间的起始位置。 那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？ 区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码： `Plain Textif (count &gt; result) result = count; **这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）** 红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。 那么不难写出如下C++代码（关键地方已经注释） ```C++ class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int result = INT32_MIN; int count = 0; for (int i = 0; i &lt; nums.size(); i++) { count += nums[i]; if (count &gt; result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置） result = count; } if (count &lt;= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 } return result; } }; 时间复杂度：O(n) 空间复杂度：O(1) 当然题目没有说如果数组为空，应该返回什么，所以数组为空的话返回啥都可以了。 不少同学认为 如果输入用例都是-1，或者 都是负数，这个贪心算法跑出来的结果是0， 这是又一次证明脑洞模拟不靠谱的经典案例，建议大家把代码运行一下试一试，就知道了，也会理解 为什么 result 要初始化为最小负数了。 个人Java实现的贪心算法：public class test { public static void main(String[] args) { int[] arr = new int[]{-2,1,-3,4,-1,2,1,-5,4}; int[] test = new int[arr.length]; test[0] = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (test[i-1] &gt; 0) { test[i] = arr[i] + test[i - 1]; }else{ test[i] = arr[i]; } } int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (test[i]&gt;max){ max = arr[i]; } } System.out.println(max); } } 动态规划当然本题还可以用动态规划来做，当前主要讲解贪心系列，后续到动态规划系列的时候会详细讲解本题的dp方法。 那么先给出我的dp代码如下，有时间的可以提前做一做： class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; vector&lt;int&gt; dp(nums.size(), 0); // dp[i]表示包括i之前的最大连续子序列和 dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i &lt; nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式 if (dp[i] &gt; result) result = dp[i]; // result 保存dp[i]的最大值 } return result; } }; 时间复杂度：O(n) 空间复杂度：O(n) 总结本题的贪心思路其实并不好想，这也进一步验证了，别看贪心理论很直白，有时候看似是常识，但贪心的题目一点都不简单！ 后续将介绍的贪心题目都挺难的，哈哈，所以贪心很有意思，别小看贪心！ 其他语言版本Javaclass Solution { public int maxSubArray(int[] nums) { if (nums.length == 1){ return nums[0]; } int sum = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++){ count += nums[i]; sum = Math.max(sum, count); // 取区间累计的最大值（相当于不断确定最大子序终止位置） if (count &lt;= 0){ count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 } } return sum; } } // DP 方法 class Solution { public int maxSubArray(int[] nums) { int ans = Integer.MIN_VALUE; int[] dp = new int[nums.length]; dp[0] = nums[0]; ans = dp[0]; for (int i = 1; i &lt; nums.length; i++){ dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); ans = Math.max(dp[i], ans); } return ans; } } Pythonclass Solution: def maxSubArray(self, nums: List[int]) -&gt; int: result = -float(&#39;inf&#39;) count = 0 for i in range(len(nums)): count += nums[i] if count &gt; result: result = count if count &lt;= 0: count = 0 return result Gofunc maxSubArray(nums []int) int { maxSum := nums[0] for i := 1; i &lt; len(nums); i++ { if nums[i] + nums[i-1] &gt; nums[i] { nums[i] += nums[i-1] } if nums[i] &gt; maxSum { maxSum = nums[i] } } return maxSum } Rustpub fn max_sub_array(nums: Vec&lt;i32&gt;) -&gt; i32 { let mut max_sum = i32::MIN; let mut curr = 0; for n in nums.iter() { curr += n; max_sum = max_sum.max(curr); curr = curr.max(0); } max_sum } Javascript:var maxSubArray = function(nums) { let result = -Infinity let count = 0 for(let i = 0; i &lt; nums.length; i++) { count += nums[i] if(count &gt; result) { result = count } if(count &lt; 0) { count = 0 } } return result }; C贪心： int maxSubArray(int* nums, int numsSize){ int maxVal = INT_MIN; int subArrSum = 0; int i; for(i = 0; i &lt; numsSize; ++i) { subArrSum += nums[i]; // 若当前局部和大于之前的最大结果，对结果进行更新 maxVal = subArrSum &gt; maxVal ? subArrSum : maxVal; // 若当前局部和为负，对结果无益。则从nums[i+1]开始应重新计算。 subArrSum = subArrSum &lt; 0 ? 0 : subArrSum; } return maxVal; } 动态规划： /** * 解题思路：动态规划： * 1. dp数组：dp[i]表示从0到i的子序列中最大序列和的值 * 2. 递推公式：dp[i] = max(dp[i-1] + nums[i], nums[i]) 若dp[i-1]&lt;0，对最后结果无益。dp[i]则为nums[i]。 * 3. dp数组初始化：dp[0]的最大子数组和为nums[0] * 4. 推导顺序：从前往后遍历 */ #define max(a, b) (((a) &gt; (b)) ? (a) : (b)) int maxSubArray(int* nums, int numsSize){ int dp[numsSize]; // dp[0]最大子数组和为nums[0] dp[0] = nums[0]; // 若numsSize为1，应直接返回nums[0] int subArrSum = nums[0]; int i; for(i = 1; i &lt; numsSize; ++i) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 若dp[i]大于之前记录的最大值，进行更新 if(dp[i] &gt; subArrSum) subArrSum = dp[i]; } return subArrSum; } TypeScript贪心 `Plain Textfunction maxSubArray(nums: number[]): number { let curSum: number = 0; let resMax: number = -Infinity; for (let i = 0, length = nums.length; i &lt; length; i++) { curSum += nums[i]; resMax = Math.max(curSum, resMax); if (curSum &lt; 0) curSum = 0; } return resMax;}; **动态规划** ```Plain Text // 动态规划 function maxSubArray(nums: number[]): number { const length = nums.length; if (length === 0) return 0; const dp: number[] = []; dp[0] = nums[0]; let resMax: number = nums[0]; for (let i = 1; i &lt; length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); resMax = Math.max(resMax, dp[i]); } return resMax; }; Scala贪心 object Solution { def maxSubArray(nums: Array[Int]): Int = { var result = Int.MinValue var count = 0 for (i &lt;- nums.indices) { count += nums(i) // count累加 if (count &gt; result) result = count // 记录最大值 if (count &lt;= 0) count = 0 // 一旦count为负，则count归0 } result } } 动态规划 object Solution { def maxSubArray(nums: Array[Int]): Int = { var dp = new Array[Int](nums.length) var result = nums(0) dp(0) = nums(0) for (i &lt;- 1 until nums.length) { dp(i) = math.max(nums(i), dp(i - 1) + nums(i)) result = math.max(result, dp(i)) // 更新最大值 } result } } 有效括号20.有效的括号 题目描述对括号的合法性判断是一个很常见且实用的问题，比如说我们写的代码，编辑器和编译器都会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 [](){}，判断起来有一点难度。 本文就来聊一道关于括号合法性判断的算法题，相信能加深你对栈这种数据结构的理解。 题目很简单，输入一个字符串，其中包含 [](){} 六种括号，请你判断这个字符串组成的括号是否合法。 `Plain TextInput: “()[]{}”Output: true Input: “([)]”Output: false Input: “{[]}”Output: true 解决这个问题之前，我们先降低难度，思考一下，**如果只有一种括号 `()`**，应该如何判断字符串组成的括号是否合法呢？ ### 一、处理一种括号 字符串中只有圆括号，如果想让括号字符串合法，那么必须做到： **每个右括号 `)` 的左边必须有一个左括号 `(` 和它匹配**。 比如说字符串 `()))((` 中，中间的两个右括号**左边**就没有左括号匹配，所以这个括号组合是不合法的。 那么根据这个思路，我们可以写出算法： ```Objective-C++ bool isValid(string str) { // 待匹配的左括号数量 int left = 0; for (char c : str) { if (c == &#39;(&#39;) left++; else // 遇到右括号 left--; if (left &lt; 0) return false; } return left == 0; } 如果只有圆括号，这样就能正确判断合法性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 left1，left2，left3 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。 但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 (()) 是合法的，但是多种括号的情况下， [(]) 显然是不合法的。 仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。 二、处理多种括号栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。 我们这道题就用一个名为 left 的栈代替之前思路中的 left 变量，遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配。 bool isValid(string str) { stack&lt;char&gt; left; for (char c : str) { if (c == &#39;(&#39; || c == &#39;{&#39; || c == &#39;[&#39;) left.push(c); else // 字符 c 是右括号 if (!left.empty() &amp;&amp; leftOf(c) == left.top()) left.pop(); else // 和最近的左括号不匹配 return false; } // 是否所有的左括号都被匹配了 return left.empty(); } char leftOf(char c) { if (c == &#39;}&#39;) return &#39;{&#39;; if (c == &#39;)&#39;) return &#39;(&#39;; return &#39;[&#39;; } ​其他语言代码20.有效的括号 pythondef isValid(self, s: str) -&gt; bool: left = [] leftOf = { &#39;)&#39;:&#39;(&#39;, &#39;]&#39;:&#39;[&#39;, &#39;}&#39;:&#39;{&#39; } for c in s: if c in &#39;([{&#39;: left.append(c) elif left and leftOf[c]==left[-1]: # 右括号 + left不为空 + 和最近左括号能匹配 left.pop() else: # 右括号 + （left为空 / 和堆顶括号不匹配） return False # left中所有左括号都被匹配则return True 反之False return not left java//基本思想：每次遇到左括号时都将相对应的右括号&#39;）&#39;，&#39;]&#39;或&#39;}&#39;推入堆栈 //如果在字符串中出现右括号，则需要检查堆栈是否为空，以及顶部元素是否与该右括号相同。如果不是，则该字符串无效。 //最后，我们还需要检查堆栈是否为空 public boolean isValid(String s) { Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for(char c : s.toCharArray()){ //是左括号就将相对应的右括号入栈 if(c==&#39;(&#39;) { stack.offerLast(&#39;)&#39;); }else if(c==&#39;{&#39;){ stack.offerLast(&#39;}&#39;); }else if(c==&#39;[&#39;){ stack.offerLast(&#39;]&#39;); }else if(stack.isEmpty() || stack.pollLast()!=c){//出现右括号，检查堆栈是否为空，以及顶部元素是否与该右括号相同 return false; } } return stack.isEmpty(); } javascript/** * @param {string} s是 * @return {boolean} */ var isValid = function (s) { let left = [] for (let c of s) { if (c === &#39;(&#39; || c === &#39;{&#39; || c === &#39;[&#39;) { left.push(c); } else { // 字符c是右括号 //出现右括号，检查堆栈是否为空，以及顶部元素是否与该右括号相同 if (left.length !== 0 &amp;&amp; leftOf(c) === left[left.length - 1]) { left.pop(); } else { // 和最近的左括号不匹配 return false; } } } return left.length === 0; }; let leftOf = function (c) { if (c === &#39;}&#39;) return &#39;{&#39;; if (c === &#39;)&#39;) return &#39;(&#39;; return &#39;[&#39;; } 吃香蕉问题875.爱吃香蕉的珂珂 1011.在D天内送达包裹的能力 ———– 二分查找到底有能运用在哪里？ 最常见的就是教科书上的例子，在有序数组中搜索给定的某个目标值的索引。再推广一点，如果目标值存在重复，修改版的二分查找可以返回目标值的左侧边界索引或者右侧边界索引。 PS：以上提到的三种二分查找算法形式在前文「二分查找详解」有代码详解，如果没看过强烈建议看看。 抛开有序数组这个枯燥的数据结构，二分查找如何运用到实际的算法问题中呢？当搜索空间有序的时候，就可以通过二分搜索「剪枝」，大幅提升效率。 说起来玄乎得很，本文先用一个具体的「Koko 吃香蕉」的问题来举个例子。 一、问题分析 也就是说，Koko 每小时最多吃一堆香蕉，如果吃不下的话留到下一小时再吃；如果吃完了这一堆还有胃口，也只会等到下一小时才会吃下一堆。在这个条件下，让我们确定 Koko 吃香蕉的最小速度（根/小时）。 如果直接给你这个情景，你能想到哪里能用到二分查找算法吗？如果没有见过类似的问题，恐怕是很难把这个问题和二分查找联系起来的。 那么我们先抛开二分查找技巧，想想如何暴力解决这个问题呢？ 首先，算法要求的是「H 小时内吃完香蕉的最小速度」，我们不妨称为 speed，请问 speed 最大可能为多少，最少可能为多少呢？ 显然最少为 1，最大为 max(piles)，因为一小时最多只能吃一堆香蕉。那么暴力解法就很简单了，只要从 1 开始穷举到 max(piles)，一旦发现发现某个值可以在 H 小时内吃完所有香蕉，这个值就是最小速度： int minEatingSpeed(int[] piles, int H) { // piles 数组的最大值 int max = getMax(piles);//找所有堆中香蕉数最多的那个 for (int speed = 1; speed &lt; max; speed++) { // 以 speed 是否能在 H 小时内吃完香蕉 if (canFinish(piles, speed, H)) return speed; } return max; } 注意这个 for 循环，就是在连续的空间线性搜索，这就是二分查找可以发挥作用的标志。由于我们要求的是最小速度，所以可以用一个搜索左侧边界的二分查找来代替线性搜索，提升效率： int minEatingSpeed(int[] piles, int H) {//这个跟上面那个代码块同等含义 // 套用搜索左侧边界的算法框架 int left = 1, right = getMax(piles) + 1;//这个加一不是很理解 while (left &lt; right) { // 防止溢出 int mid = left + (right - left) / 2; if (canFinish(piles, mid, H)) {//mid为速度 right = mid; } else { left = mid + 1; } } return left; } 剩下的辅助函数也很简单，可以一步步拆解实现： // 时间复杂度 O(N) boolean canFinish(int[] piles, int speed, int H) { int time = 0; for (int n : piles) { time += timeOf(n, speed); } return time &lt;= H; } int timeOf(int n, int speed) {//n代表当前堆的香蕉数 return (n / speed) + ((n % speed &gt; 0) ? 1 : 0); } int getMax(int[] piles) {//找所有堆中香蕉数最多的那个 int max = 0; for (int n : piles) max = Math.max(n, max); return max; } 至此，借助二分查找技巧，算法的时间复杂度为 O(NlogN)。 二、扩展延伸类似的，再看一道运输问题： 要在 D 天内运输完所有货物，货物不可分割，如何确定运输的最小载重呢（下文称为 cap）？ 其实本质上和 Koko 吃香蕉的问题一样的，首先确定 cap 的最小值和最大值分别为 max(weights) 和 sum(weights)。 我们要求最小载重，所以可以用搜索左侧边界的二分查找算法优化线性搜索： // 寻找左侧边界的二分查找 int shipWithinDays(int[] weights, int D) { // 载重可能的最小值 int left = getMax(weights); // 载重可能的最大值 + 1 int right = getSum(weights) + 1; while (left &lt; right) { int mid = left + (right - left) / 2; if (canFinish(weights, D, mid)) { right = mid; } else { left = mid + 1; } } return left; } // 如果载重为 cap，是否能在 D 天内运完货物？ boolean canFinish(int[] w, int D, int cap) { int i = 0; for (int day = 0; day &lt; D; day++) { int maxCap = cap; while ((maxCap -= w[i]) &gt;= 0) { i++; if (i == w.length) return true; } } return false; } 通过这两个例子，你是否明白了二分查找在实际问题中的应用？ `Plain Textfor (int i = 0; i &lt; n; i++) if (isOK(i)) return ans;​ ## 其他语言代码 [875.爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas) [1011.在D天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days) ### c++ [cchroot](https://github.com/cchroot) 提供 C++ 代码： ```C++ class Solution { public: int minEatingSpeed(vector&lt;int&gt;&amp; piles, int H) { // 二分法查找最小速度 // 初始化最小速度为 1，最大速度为题目设定的最大值 10^9 // 这里也可以遍历 piles 数组，获取数组中的最大值，设置 right 为数组中的最大值即可(因为每堆香蕉1小时吃完是最快的) // log2(10^9) 约等于30，次数不多，所以这里暂时就不采取遍历获取最大值了 int left = 1, right = pow(10, 9); while (left &lt; right) { // 二分法基本的防止溢出 int mid = left + (right - left) / 2; // 以 mid 的速度吃香蕉，是否能在 H 小时内吃完香蕉 if (!canFinish(piles, mid, H)) left = mid + 1; else right = mid; } return left; } // 以 speed 的速度是否能把香蕉吃完 bool canFinish(vector&lt;int&gt;&amp; piles, int speed, int H) { int time = 0; // 遍历累加时间 time for (int p: piles) time += (p - 1) / speed + 1; return time &lt;= H; // time 小于等于 H 说明能在 H 小时吃完返回 true, 否则返回 false } }; pythontonytang731 提供 Python3 代码： `Plain Textimport math​class Solution: def minEatingSpeed(self, piles, H): # 初始化起点和终点， 最快的速度可以一次拿完最大的一堆 start = 1 end = max(piles) # while loop进行二分查找 while start + 1 &lt; end: mid = start + (end - start) // 2 # 如果中点所需时间大于H, 我们需要加速， 将起点设为中点 if self.timeH(piles, mid) &gt; H: start = mid # 如果中点所需时间小于H, 我们需要减速， 将终点设为中点 else: end = mid # 提交前确认起点是否满足条件，我们要尽量慢拿 if self.timeH(piles, start) &lt;= H: return start # 若起点不符合， 则中点是答案 return end def timeH(self, piles, K): # 初始化时间 H = 0 #求拿每一堆需要多长时间 for pile in piles: H += math.ceil(pile / K) return H ### javascript 用js写二分的时候，一定要注意使用`Math.floor((right - left) / 2)`或者`paserInt()`将结果整数化！由于js不声明变量类型，很多时候就很难发现自己浮点数、整数使用的问题。 [875.爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas) ```Plain Text /** * @param {number[]} piles * @param {number} H * @return {number} */ var minEatingSpeed = function (piles, H) { // 套用搜索左侧边界的算法框架 let left = 1, right = getMax(piles) + 1; ​ while (left &lt; right) { // 防止溢出 let mid = left + Math.floor((right - left) / 2); if (canFinish(piles, mid, H)) { right = mid; } else { left = mid + 1; } } return left; }; ​ // 时间复杂度 O(N) let canFinish = (piles, speed, H) =&gt; { let time = 0; for (let n of piles) { time += timeOf(n, speed); } return time &lt;= H; } ​ // 计算所需时间 let timeOf = (n, speed) =&gt; { return Math.floor( (n / speed) + ((n % speed &gt; 0) ? 1 : 0) ); } ​ let getMax = (piles) =&gt; { let max = 0; for (let n of piles) { max = Math.max(n, max); } return max; } ​ 传送门：1011.在D天内送达包裹的能力 `Plain Text// 第1011题/** @param {number[]} weights @param {number} D @return {number}*/// 寻找左侧边界的二分查找var shipWithinDays = function (weights, D) { // 载重可能的最小值 let left = getMax(weights); // 载重可能的最大值 + 1 let right = getSum(weights) + 1; while (left &lt; right) { let mid = left + Math.floor((right - left) / 2); if (canFinish(weights, D, mid)) { right = mid; } else { left = mid + 1; } } return left;} // 如果载重为 cap，是否能在 D 天内运完货物？let canFinish = (w, D, cap) =&gt; { let i = 0; for (let day = 0; day &lt; D; day++) { let maxCap = cap; while ((maxCap -= w[i]) &gt;= 0) { i++; if (i === w.length) return true; } } return false;} let getMax = (piles) =&gt; { let max = 0; for (let n of piles) { max = Math.max(n, max); } return max;} /** @param {number[]} weights// 获取货物总重量*/let getSum = (weights) =&gt; { return weights.reduce((total, cur) =&gt; { total += cur; return total }, 0)}`","categories":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zhaoshengmu.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://zhaoshengmu.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}]},{"title":"","slug":"算法 7b1a8214-a20f-468d-b7c0-ca4a94df6fd6/接雨水 6f64b795-7739-436f-a3ff-0fe404020c75","date":"2022-08-18T11:46:13.348Z","updated":"2022-08-18T11:45:50.000Z","comments":true,"path":"2022/08/18/算法 7b1a8214-a20f-468d-b7c0-ca4a94df6fd6/接雨水 6f64b795-7739-436f-a3ff-0fe404020c75/","link":"","permalink":"https://zhaoshengmu.top/2022/08/18/算法 7b1a8214-a20f-468d-b7c0-ca4a94df6fd6/接雨水 6f64b795-7739-436f-a3ff-0fe404020c75/","excerpt":"","text":"个人解法：package src.main.java; class Main { public static void main(String[] args) { int[] arr = new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}; int count = 0; //此处运用双指针写法 for (int i = 0; i+1 &lt; arr.length; ) { for (int j = i + 1; j&lt;arr.length; j++) { boolean flag = hasBig(arr, i); if (arr[i] &gt; arr[j] &amp;&amp; flag) {//能装水 count += arr[i] - arr[j]; // System.out.println(i + &quot; &quot;+arr[i]); } else { i = j; break; } System.out.println(count); } } System.out.println(count); } static boolean hasBig(int[] arr, int i) {//代表右边有大于当前的，能拦住中间的水 boolean flag = false; for (int x = i + 1; x &lt; arr.length; x++) { if (arr[x] &gt;= arr[i]) { flag = true; break; } } return flag; } } 很好，花了我快一个小时，然后没算出来，起码没完全算出来，算对了百分之五十，这种情况最恶心人了，就是某一部分情况没考虑到，然后再看一眼桌子，五六根头发，绷不住。要判断hasBig不要判断arr[i]，而应该用arr[j]因为可能如4，2,3这种，3&lt;4但是3&gt;2也能存住水 艹，这代码不改了，改就要大改了而且逻辑还不一定严谨，妈的，以后看到类别为难题的直接先看答案 上图为第一次提交 终究还是没舍得放弃，又改了将近半小时，终于通过了，真的会谢,只击败了百分之十 本题个人解法思路：双指针，首先一开始设置一个指针i初始为零，第二个指针j初始为i+1,然后循环（条件就是数组别越界）然后循环里面先通过hasBig方法判断j指针后面有无大于arr[j]的值，如果有则返回右侧的最大值，如果没有则返回0；然后判断arr[i]是否大于arrr[j]（只有大于才可能在j处存水）如果大于则再判断arr[i]和max的大小，用较小者减去arr[j]就是在j处存的水，如果小于等于这说明存不了水让i=j（因为i和j中间的都已经判断过有无存水了）后再break跳出循环继续下一轮。 package src.main.java; class Main { public static void main(String[] args) { int[] arr = new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}; int count = 0; //此处运用双指针写法 for (int i = 0; i + 1 &lt; arr.length; ) { for (int j = i + 1; j &lt; arr.length; j++) { int max = hasBig(arr, j); if (arr[i] &gt; arr[j] &amp;&amp; max != 0) {//能装水 if (arr[i] &lt;= max) { count += arr[i] - arr[j]; } else { count += max - arr[j]; } } else { i = j; break; } } } System.out.println(count); } static int hasBig(int[] arr, int i) {//代表右边有大于当前的，能拦住中间的水 int max = 0; for (int j = i + 1; j &lt; arr.length; j++) { if (arr[j] &gt; max) { max = arr[j]; } } if(max&lt;=arr[i]){ max=0; } return max; } } 我一直觉得，如果算法中有很多if else，排除一些特殊情况不得不用后，这代码大概率写的很low。 正解：我们不要想整体，而应该去想局部；就像之前的文章写的动态规划问题处理字符串问题，不要考虑如何处理整个字符串，而是去思考应该如何处理每一个字符。 这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 i，能装下多少水呢？ 能装 2 格水，因为 height[i] 的高度为 0，而这里最多能盛 2 格水，2-0=2。 为什么位置 i 最多能盛 2 格水呢？因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为 l_max 和 r_max；位置 i 最大的水柱高度就是 min(l_max, r_max)。 更进一步，对于位置 i，能够装的水为： `Plain Textwater[i] = min( # 左边最高的柱子 max(height[0..i]), # 右边最高的柱子 max(height[i..end]) ) - height[i] 这就是本问题的核心思路，我们可以简单写一个暴力算法： ### 暴力：(试了下超时了） ```C++ int trap(vector&lt;int&gt;&amp; height) { int n = height.size(); int res = 0; for (int i = 1; i &lt; n - 1; i++) { int l_max = 0, r_max = 0; // 找右边最高的柱子 for (int j = i; j &lt; n; j++) r_max = max(r_max, height[j]); // 找左边最高的柱子 for (int j = i; j &gt;= 0; j--) l_max = max(l_max, height[j]); // 如果自己就是最高的话， // l_max == r_max == height[i] res += min(l_max, r_max) - height[i]; } return res; } 有之前的思路，这个解法应该是很直接粗暴的，时间复杂度 O(N^2)，空间复杂度 O(1)。但是很明显这种计算 r_max 和 l_max 的方式非常笨拙，一般的优化方法就是备忘录。 备忘录解法：（通俗易懂）之前的暴力解法，不是在每个位置 i 都要计算 r_max 和 l_max 吗？我们直接把结果都提前计算出来，别傻不拉几的每次都遍历，这时间复杂度不就降下来了嘛。 我们开两个数组 r_max 和 l_max 充当备忘录，l_max[i] 表示位置 i 左边最高的柱子高度，r_max[i] 表示位置 i 右边最高的柱子高度。预先把这两个数组计算好，避免重复计算： 最终备忘录的代码： class Solution { public int trap(int[] height) { if (height == null || height.length == 0) return 0; int n = height.length; int res = 0; // 数组充当备忘录 int[] maxLeft = new int[n]; int[] maxRight = new int[n]; // 初始化 base case maxLeft[0] = height[0]; maxRight[n - 1] = height[n - 1]; // 从左向右计算 maxLeft for (int i = 1; i &lt; n; i++) { maxLeft[i] = Math.max(maxLeft[i - 1], height[i]); } // 从右向左计算 maxRight for (int i = n - 2; i &gt;= 0; i--) { maxRight[i] = Math.max(maxRight[i + 1], height[i]); } // 计算答案 for (int i = 1; i &lt; n; i++) { res += Math.min(maxLeft[i], maxRight[i]) - height[i]; } return res; } } 这个优化其实和暴力解法思路差不多，就只是避免了重复计算，把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N)。下面来看一个精妙一些的解法，能够把空间复杂度降低到 O(1)。 双指针解法：（跟我的有类似） 这种解法的思路是完全相同的，但在实现手法上非常巧妙，我们这次也不要用备忘录提前计算了，而是用双指针边走边算，节省下空间复杂度。 首先，看一部分代码： int trap(vector&lt;int&gt;&amp; height) { int n = height.size(); int left = 0, right = n - 1; int l_max = height[0]; int r_max = height[n - 1]; while (left &lt;= right) { l_max = max(l_max, height[left]); r_max = max(r_max, height[right]); left++; right--; } } 对于这部分代码，请问 l_max 和 r_max 分别表示什么意义呢？ 很容易理解，l_max 是 height[0..left] 中最高柱子的高度，r_max 是 height[right..end] 的最高柱子的高度。 明白了这一点，直接看解法： int trap(vector&lt;int&gt;&amp; height) { if (height.empty()) return 0; int n = height.size(); int left = 0, right = n - 1; int res = 0; int l_max = height[0]; int r_max = height[n - 1]； while (left &lt;= right) { l_max = max(l_max, height[left]); r_max = max(r_max, height[right]); if (l_max &lt; r_max) { res += l_max - height[left]; left++; } else { res += r_max - height[right]; right--; } } return res; }","categories":[],"tags":[],"keywords":[]},{"title":"关于失眠","slug":"关于失眠","date":"2022-08-09T13:37:03.000Z","updated":"2022-08-11T14:13:22.673Z","comments":true,"path":"2022/08/09/关于失眠/","link":"","permalink":"https://zhaoshengmu.top/2022/08/09/关于失眠/","excerpt":"","text":"The truth is a beautiful and terrible thing, and should therefore be treated with great caution. David LevithanWide Awake 起因感觉可能真的是老了吧，现在晚上入睡时间越来越晚，时常失眠，很是痛苦。一直想办法但是都效果甚微，不过我也发现了一些规律，比如睡前不要看手机或者让大脑比较活跃的知识，这样能有效加速入睡速度，但是还不是很快。 冥想之前我哥一直给我推荐这个但是我一直没怎么尝试，不过当时失眠有些严重，所以也试了试，发现是真的有用，当时用的时候大概十五分钟内必定入睡，它的原理是先绷紧身体肌肉再放松，这样达到快速使身体放松的状态。不过我现在用它用的比较少，因为用的越多感觉越有用然后心理上总想犯贱试试自己强行不入睡会怎么样。 软件我用的是冥想星球，里面有一个”睡前放松(轻度）”，就是这个特别有用，它还有一个重度的，但是感觉没有轻度的好用。（写博客好累啊，凑不出字数了…就这样吧…)","categories":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}]},{"title":"JSP&三层架构","slug":"JSP&三层架构","date":"2022-08-06T14:16:01.000Z","updated":"2022-08-08T11:22:06.878Z","comments":true,"path":"2022/08/06/JSP&三层架构/","link":"","permalink":"https://zhaoshengmu.top/2022/08/06/JSP&三层架构/","excerpt":"","text":"day26-JSP&amp;三层架构教学目标 能够说出el表达式的作用 能够使用el表达式获取javabean的属性 能够使用jstl标签库的if标签 能够使用jstl标签库的foreach标签 能够使用三层架构模式完成转账案例 能够使用ThreadLocal 能够完成转账案例 第一章-EL表达式知识点-EL表达式概述1.目标 能够说出el表达式的作用 2.讲解2.1.什么是El表达式​ 域对象： ​ request：一次请求 ​ session：一次会话 ​ ServletContext：整个应用 ​ API： ​ getAttribute(name); ​ &lt;%=getAttribute(name) %&gt; ​ ${name} ​ Expression Language:表达式语言, jsp2.0之后内置在jsp里面 ​ 目的：为了使JSP写起来更加简单, 取值(取的域对象里面存的值)更加简单。(代替脚本 &lt;%= %&gt;) 2.2.EL语法​ ${el表达式} 2.3.EL表达式的用途​ 1.获取数据. 获取的是域(request,session,ServletContext)对象中存储的数据 ​ 2.EL执行运算(算术运算及逻辑运算) 3.小结 EL概念：表达式语言，目的简化开发 EL语法：${el表达式} 作用： 获取域对象中的数据 执行运算 知识点-El获取数据1.目标 能够使用el表达式获取域对象里面的数据(先要把数据存到域对象里面) 2.路径 获取简单数据类型数据(基本类型,字符串) 获取数组 获取list 获取Map 获取bean 3.讲解3.1获取简单数据类型数据​ 语法:${requestScope|sessionScope|applicationScope.属性名}; ​ 快捷写法:==${属性名}, 属性名就是存在域对象里面的key== &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--EL获取简单类型数据 1.在域对象中存储数据 2.使用EL表达式获取数据 ${key} 注意： 情况一： EL表达式获取不到数据返回&quot;&quot; 情况二：EL表达式获取数据时，会从作用域范围小的到范围大的【request--&gt;session--&gt;application】进行查找，找到就停止返回，找不到继续向下查找。 --%&gt; &lt;% //request 、 session 、ServletContext //jsp内置对象：request、session、application //request是jsp的内置对象 jsp生来就有 可以不用创建 直接使用 request.setAttribute(&quot;name&quot;,&quot;tom&quot;); session.setAttribute(&quot;age&quot;,18); //application就是ServletContext对象 只不过是在jsp中换了个马甲 application.setAttribute(&quot;address&quot;,&quot;深圳&quot;); //在request作用域中在存储一个age request.setAttribute(&quot;age&quot;,20); %&gt; &lt;%--获取域对象中存储的数据--%&gt; &lt;h3&gt;老方式：&lt;%=request.getAttribute(&quot;name&quot;) %&gt;&lt;/h3&gt; &lt;h3&gt;EL表达式：${requestScope.name}&lt;/h3&gt; &lt;h3&gt;简化方式：${name}&lt;/h3&gt; &lt;hr&gt; &lt;h3&gt;老方式：&lt;%=session.getAttribute(&quot;age&quot;) %&gt;&lt;/h3&gt; &lt;h3&gt;EL表达式：${sessionScope.age}&lt;/h3&gt; &lt;h3&gt;简化方式：${age}&lt;/h3&gt; &lt;hr&gt; &lt;h3&gt;老方式：&lt;%=application.getAttribute(&quot;address&quot;) %&gt;&lt;/h3&gt; &lt;h3&gt;EL表达式：${applicationScope.address}&lt;/h3&gt; &lt;h3&gt;简化方式：${address}&lt;/h3&gt; &lt;%--情况一：当获取的数据，在域对象中不存在时使用EL表达式获取会出现什么情况？ EL表达式获取不到数据返回&quot;&quot;--%&gt; &lt;hr&gt; &lt;h3&gt;老方式：&lt;%=request.getAttribute(&quot;sex&quot;) %&gt;&lt;/h3&gt; &lt;h3&gt;EL表达式：${requestScope.sex}&lt;/h3&gt; &lt;%--情况二：当多个作用域中存储相同key的数据，EL表达式使用简化方式获取时，会从范围小的到范围大的【request--&gt;session--&gt;application】进行查找，找到就停止返回--%&gt; &lt;hr&gt; &lt;h3&gt;EL表达式：${requestScope.age}&lt;/h3&gt; &lt;h3&gt;EL表达式：${sessionScope.age}&lt;/h3&gt; &lt;h3&gt;简化方式：${age}&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 3.2获取数组​ 语法: ${key[下标]} key就是域对象里面存的key 3.3获取list​ 语法:${list属性名[index]}或者${list属性名.get(index)};list属性名就是存入域对象里面的key 3.4获取Map​ 语法:${map属性名.键} 或 ${map属性名.get(&quot;键&quot;)} 或${map属性名[键],map属性名就是存入域对象里面的key } ​ 注意：当map的键比较特殊(eg：”1”、”a.ba.c”)时，此时使用点的方式会报错，可以选择使用[]的方式。 &lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page import=&quot;java.util.Map&quot; %&gt; &lt;%@ page import=&quot;java.util.HashMap&quot; %&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- EL获取数据特点： 1.EL获取数据会进行自动类型转换 --%&gt; &lt;%--1.在域对象中存储数据--%&gt; &lt;% /*1.1：域对象中存储数组*/ String[] names = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;}; request.setAttribute(&quot;names&quot;,names); /*1.2：域对象中存储list集合*/ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;篮球&quot;); list.add(&quot;足球&quot;); list.add(&quot;混球&quot;); request.setAttribute(&quot;list&quot;,list); /*1.3：获取Map集合中的元素*/ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;cn&quot;,&quot;中国&quot;); map.put(&quot;jp&quot;,&quot;小日本&quot;); map.put(&quot;usa&quot;,&quot;漂亮国&quot;); request.setAttribute(&quot;map&quot;,map); %&gt; &lt;%--2.使用EL表达式获取域对象中的数据--%&gt; &lt;%--2.1：获取数组中的第二个元素 语法：${key[下标]}--%&gt; &lt;h3&gt;老方式：&lt;%=((String[])request.getAttribute(&quot;names&quot;))[1]%&gt;&lt;/h3&gt; &lt;h3&gt;获取数组数据：${names[1]}&lt;/h3&gt; &lt;hr&gt; &lt;%--2.2：获取list集合中的第三个元素 语法：${key[下标]} 或 ${key.get(下标)}--%&gt; &lt;h3&gt;获取list数据：${list[2]}&lt;/h3&gt; &lt;h3&gt;获取list数据：${list.get(2)}&lt;/h3&gt; &lt;hr&gt; &lt;%--2.3:获取map集合中的数据 语法：${key[&quot;map的键&quot;]} 或 ${key.get(&quot;map的键&quot;)} 或 ${key.map的键}--%&gt; &lt;h3&gt;获取map集合中键cn对应值：${map[&quot;cn&quot;]}&lt;/h3&gt; &lt;h3&gt;获取map集合中键cn对应值：${map.get(&quot;cn&quot;)}&lt;/h3&gt; &lt;h3&gt;获取map集合中键cn对应值：${map.cn}&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 3.5 获取bean​ ==语法:${key.javabean属性}== ​ 依赖getxxx()方法; eg: getPassword()—去掉get–&gt;Password()—-首字母小写—&gt;password &lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page import=&quot;java.util.Map&quot; %&gt; &lt;%@ page import=&quot;java.util.HashMap&quot; %&gt; &lt;%@ page import=&quot;com.itheima.bean.User&quot; %&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- EL获取数据特点： 1.EL获取数据会进行自动类型转换 --%&gt; &lt;%--1.在域对象中存储数据--%&gt; &lt;% //使用域对象存储javabean对象数据 User user = new User(); user.setName(&quot;zs&quot;); user.setPwd(&quot;123&quot;); request.setAttribute(&quot;user&quot;,user); //java对象属性：就是去掉get/set之后的单词首字母小写 得到就是属性 getName--&gt;Name--&gt;name %&gt; &lt;%--2.使用EL表达式获取javabeaan数据 语法：${key.javabean属性名称}--%&gt; &lt;h3&gt;获取user对象的name属性值：${user.name}&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 3.6：获取特殊key的值&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page import=&quot;java.util.Map&quot; %&gt; &lt;%@ page import=&quot;java.util.HashMap&quot; %&gt; &lt;%@ page import=&quot;com.itheima.bean.User&quot; %&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- EL获取数据特点： 1.EL获取数据会进行自动类型转换 --%&gt; &lt;%--1.在域对象中存储数据--%&gt; &lt;% request.setAttribute(&quot;a.b.c.d&quot;,&quot;特殊key a.b.c.d&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;cn&quot;,&quot;中国&quot;); map.put(&quot;small.jp&quot;,&quot;小日本&quot;); request.setAttribute(&quot;map&quot;,map); %&gt; &lt;%--2.使用EL表达式获取--%&gt; &lt;h3&gt;${a.b.c.d}&lt;/h3&gt; &lt;hr&gt; &lt;h3&gt;${[&quot;a.b.c.d&quot;]}&lt;/h3&gt; &lt;hr&gt; &lt;h3&gt;${requestScope[&quot;a.b.c.d&quot;]}&lt;/h3&gt; &lt;hr&gt; &lt;h3&gt;${map.small.jp}&lt;/h3&gt; &lt;h3&gt;${map[&quot;small.jp&quot;]}&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 4.小结1. EL获取域对象中存储的数据 语法：${key} 2. 获取简单数据类型数据 ：==${key}== 3. 获取数组元素：==${key[下标]}== 4. 获取list集合元素：==${key[下标]} 或${key.get(下标)}== 5. 获取map集合元素：==${key[&quot;map的键&quot;]} 或 ${key.get(&quot;map的键&quot;)} 或 ${key.map的键}== 6. 获取javabean属性值：==${key.javabean属性名称}== 7. 注意： 1. EL获取不到数据返回&quot;&quot; 2. EL获取会进行自动类型转换 3. EL获取数据从范围小的到大的【request--&gt;session--&gt;application】进行查找，找到就停止。 知识点-EL执行运算1.目标 掌握EL执行运算 2.讲解 2.1算术运算​ +,-,*,/ +:加号在EL表达式中代表加运算，不作拼接使用,如果是数字的字符串形式，则EL表达式会自动进行类型转换，然后再进行算术运算 2.2关系运算​ &lt; &gt;= &lt;= != == 2.3逻辑运算​ &amp;&amp; || ! 2.4非空判断【重点】​ empty， ​ 1. 判断一个对象是否为null,为null返回true ​ 2. 判断集合长度是否为0,集合为null或长度为0返回true ​ 3. 判断一个字符串是否为 null或””，如果是则返回true ​ not empty ​ 语法: ${empyt 属性名};属性名 就是域对象里面的key值 &lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page import=&quot;java.util.Map&quot; %&gt; &lt;%@ page import=&quot;java.util.HashMap&quot; %&gt; &lt;%@ page import=&quot;com.itheima.bean.User&quot; %&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--EL执行运算 1.+：表示加运算，不表示拼接 如果+两边有一方无法转换为数字 则报错 2.empty 2.1：判断一个对象是否为null 是返回true 2.2：判断一个字符串是否为null或&quot;&quot; 是返回true 2.3：判断一个list集合是否为null或长度为0 是返回true 3.not empty:判断是否非null 非null 返回true --%&gt; &lt;h4&gt;${3+4}&lt;/h4&gt; &lt;h4&gt;${3+&quot;4&quot;}&lt;/h4&gt; &lt;%--&lt;h4&gt;${3+&quot;4a&quot;}&lt;/h4&gt;--%&gt; &lt;% User user = new User(); request.setAttribute(&quot;user&quot;,user); String str1 = null; String str2 = &quot;&quot;; request.setAttribute(&quot;str1&quot;,str1); request.setAttribute(&quot;str2&quot;,str2); List list1 = null; List list2 = new ArrayList(); request.setAttribute(&quot;list1&quot;,list1); request.setAttribute(&quot;list2&quot;,list2); %&gt; &lt;h4&gt;user对象是否为null：${empty user}&lt;/h4&gt; &lt;h4&gt;str1是否为null或&quot;&quot;：${empty str1}&lt;/h4&gt; &lt;h4&gt;str2是否为null或&quot;&quot;：${empty str2}&lt;/h4&gt; &lt;h4&gt;list1是否为null或长度为0：${empty list1}&lt;/h4&gt; &lt;h4&gt;list2是否为null或长度为0：${empty list2}&lt;/h4&gt; &lt;h4&gt;user对象是否非null：${not empty user}&lt;/h4&gt; &lt;/body&gt; &lt;/html&gt; 3.小结 注意: +只能做加法运算,不能拼接字符串 ,如果加号两边有一方无法转换为数字，则报错 empty：判断是否为null 为null返回true 判断一个对象是否为null 判断字符串是否为null或”” 判断list集合是否为null或长度为0第二章-JSTL标签库 知识点-JSTL标签库概述1.目标 掌握什么是JSTL标签库 2.讲解JSTL和EL是黄金搭档：JSTL作逻辑处理，EL获取数据展示。 2.1什么是JSTL标签库​ JSTL（JSP Standard Tag Library，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，是由apache的jakarta小组来维护的。这个JSTL标签库没有集成到JSP的, 要使用的话, 需要导jar包. 2.2JSTL标签库的作用​ 为了简化在jsp页面上操作数据; eg: 遍历数据 判断数据等 2.3JSTL标签库的类别 3.小结 JSTL：JSP标签标准标签库，用于逻辑处理，可以替代java小脚本。 作用：遍历数据 判断数据 使用：由于JSTL没有被集成到jsp中，所以使用时需要导入jar包 知识点-JSTL核心标签库1.目标 掌握if,foreach标签的使用 2.讲解2.1核心标签库使用步骤 导入jar包 在JSP页面上导入核心标签库&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 2.3if标签 语法 &lt;c:if test=&quot;el表达式${..}&quot; [var=&quot;给之前的表达式的结果起个名字&quot;] [scope=&quot;将结果保存在那个域中 默认page&quot;]&gt; &lt;/c:if&gt; 实例 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% //域对象存储数据 request.setAttribute(&quot;age&quot;,6); %&gt; &lt;%-- if标签：用于判断 test属性值为true，则执行if标签体中的内容，为false，不执行 test：设置判断条件 可以使用EL表达式进行判断 返回一个boolean类型的结果true|false var：声明一个变量 存储判断结果 scope：将判断结果变量存入到一个作用域中 方便后期使用 --%&gt; &lt;c:if test=&quot;${age &gt;= 7}&quot; var=&quot;flag&quot; scope=&quot;request&quot;&gt; &lt;h4&gt;可以上小学了&lt;/h4&gt; &lt;/c:if&gt; &lt;c:if test=&quot;${age&lt;7}&quot;&gt; &lt;h4&gt;回家玩泥巴去吧&lt;/h4&gt; &lt;/c:if&gt; &lt;h3&gt;if判断结果：${requestScope.flag}&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 小结 语法 &lt;c:if test=&quot;${} &quot;&gt;&lt;/c:if&gt; 特点 如果test里面的是true, if标签体里面的就会执行 如果test里面的是false, if标签体里面的就不会执行 没有else的 2.4choose标签 实例 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% //域对象存储数据 request.setAttribute(&quot;age&quot;,15); //需求：大于6岁可以上小学 大于13岁可以上中学 大于18岁可以上大学 如果小于等于6岁回家玩泥巴 //分析：使用多重if判断实现 //实现： %&gt; &lt;%--c:choose表示的就是多重if选择结构 c:when表示的就是if判断 c:otherwise表示的就是else--%&gt; &lt;c:choose&gt; &lt;c:when test=&quot;${age&gt;18}&quot;&gt; 上大学 &lt;/c:when&gt; &lt;c:when test=&quot;${age&gt;13}&quot;&gt; 上中学 &lt;/c:when&gt; &lt;c:when test=&quot;${age&gt;6}&quot;&gt; 上小学 &lt;/c:when&gt; &lt;c:otherwise&gt; 回家玩泥巴 &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt; &lt;/html&gt; 2.5foreach标签 简单的使用: &lt;%--forEach标签的简单使用 需求：使用foreach标签遍历1-10 每个数字显示字题为红色 forEach标签：用于遍历数据 var：迭代变量 在foreach标签体中获取迭代变量数据 需要使用el表达式 begin：开始 从第几个开始遍历 end：结束 遍历到第几个结束 step：步长 间隔 varStatus：记录迭代变量的状态信息 --%&gt; &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;2&quot; varStatus=&quot;status&quot;&gt; &lt;font color=&quot;red&quot;&gt;${status.index} --&gt; ${i}&lt;/font&gt;&lt;br&gt; &lt;/c:forEach&gt; 复杂的使用: ​ c:forEach中的varStatus属性。 指向一个字符串，该字符串引用一个对象。 map.put(&quot;vs&quot;,一个对象); 这个对象记录着当前遍历的元素的一些信息： index:返回索引。从0开始 count:返回计数。从1开始 last:是否是最后一个元素 first:是否是第一个元素 &lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;com.itheima.bean.User&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--forEach标签的实际使用 需求：查询操作，查询所有用户 在jsp页面显示 分析：操作数据库，查询得到数据封装到list集合中 ，将数据保存到域对象中，在jsp页面就可以获取到展示 --%&gt; &lt;% List&lt;User&gt; list = new ArrayList&lt;&gt;(); User user1 = new User(); user1.setName(&quot;zs&quot;); user1.setPwd(&quot;123&quot;); User user2 = new User(); user2.setName(&quot;ls&quot;); user2.setPwd(&quot;456&quot;); User user3 = new User(); user3.setName(&quot;ww&quot;); user3.setPwd(&quot;789&quot;); list.add(user1); list.add(user2); list.add(user3); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;table border=&quot;1px&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;300px&quot;&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;/tr&gt; &lt;%--forEach遍历：每遍历一次 输出一行用户信息记录显示在页面 items：要遍历的数组/集合 使用el表达式获取 var：声明迭代变量 接收数组|集合中的每一个元素 varStatus：状态 status.index获取到索引下标 --%&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;user&quot; varStatus=&quot;status&quot;&gt; &lt;tr&gt; &lt;td&gt;${status.index+1}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.pwd}&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 3.小结 准备 导入jar包 在要使用jstl标签库的jsp页面引入jstl标签库 &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; if标签 &lt;c:if test=&quot;返回boolean类型数据的el表达式&quot;&gt; &lt;/c:if&gt; choose标签 &lt;c:choose&gt; &lt;c:when test=&quot;判断条件1&quot;&gt;&lt;/c:when&gt; &lt;c:when test=&quot;判断条件2&quot;&gt;&lt;/c:when&gt; ... &lt;c:otherwise&gt;&lt;/c:otherwise&gt; &lt;/c:choose&gt; foreach标签 foreach简单使用 &lt;c:forEach var=&quot;迭代变量&quot; begin=&quot;开始&quot; end=&quot;结束&quot; step=&quot;步长&quot; varStatus=&quot;迭代变量状态&quot;&gt; ${迭代变量} &lt;/c:forEach&gt; foreach实际使用 &lt;c:forEach items=&quot;要遍历的集合 使用el表达式获取&quot; var=&quot;迭代变量&quot; varStatus=&quot;迭代变量状态&quot;&gt; ${迭代变量} &lt;/c:forEach&gt; 第三章-综合案例和开发模式案例-完成转账的案例v1一.需求 当单击提交按钮，付款方向收款方按照输入的金额转账。 二,分析 三,实现1.案例的准备工作 数据库的准备 create database day25; use day25; create table account( id int primary key auto_increment, name varchar(20), money double ); insert into account values (null,&#39;zs&#39;,1000); insert into account values (null,&#39;ls&#39;,1000); insert into account values (null,&#39;ww&#39;,1000); 页面 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; &lt;table border=&quot;1px&quot; width=&quot;500px&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;付款方&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;from&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;收款方&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;to&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;金额&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; jar包 工具类 配置文件 2.代码实现 UserServlet package com.itheima.web; import com.itheima.utils.C3P0Utils; import org.apache.commons.dbutils.QueryRunner; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.sql.SQLException; @WebServlet(&quot;/transfer&quot;) public class TransferServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { //0.中文乱码处理 request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); // 1.获取请求参数【付款方、收款方、金额】 String from = request.getParameter(&quot;from&quot;); //付款方 String to = request.getParameter(&quot;to&quot;); //收款方 double money = Double.parseDouble(request.getParameter(&quot;money&quot;)); //转账金额 // 2.处理业务【判断付款方收款方是否存在 金额是否合理 假设一切OK】 // 3.操作数据库【两个update语句 钱减少 钱增加】rows1 rows2 QueryRunner queryRunner = new QueryRunner(C3P0Utils.getDataSource()); String sql1 = &quot;update account set money=money-? where name=?&quot;; int rows1 = queryRunner.update(sql1, money, from); String sql2 = &quot;update account set money=money+? where name=?&quot;; int rows2 = queryRunner.update(sql2, money, to); // 4.根据处理结果进行响应 if(rows1&gt;0 &amp;&amp; rows2&gt;0){ response.getWriter().print(&quot;转账成功！&quot;); }else{ response.getWriter().print(&quot;转账失败！&quot;); } } catch (Exception e) { e.printStackTrace(); response.getWriter().print(&quot;服务器异常！&quot;); } } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } } 四.小结 转账功能：操作数据库 付款方钱减少 收款方钱增加 编写TransferServlet 获取请求参数 处理业务 响应 知识点-开发模式1.目标 理解模式二(MVC)和模式三(三层架构) 2.讲解2.1JSP的开发模式一【了解】jsp+javabean：实现 javaBean:实体类。特点：私有化的属性、公共的getter setter方法、无参的构造。 问题： ​ 1.所有的代码都在jsp中 会存在大量代码冗余 不利于代码维护修改 ​ 2.jsp已经属于上个时代的技术了 过时了 jsp执行效率非常低 jsp–&gt;翻译成java代码–&gt;编译class文件–&gt;执行 2.2JSP的开发模式二​ JSP【html】 + Servlet + JavaBean 称为MVC的开发模式. ​ MVC:开发模式 ​ M：model 模型 （javaBean：处理业务封装数据） ​ V：View 视图 （JSP|html：展示数据） ​ C：controller 控制器 （Servlet：接收请求进行分发，做为控制器） 2.3模式三: 三层架构 软件中分层：按照不同功能分为不同层，通常分为三层：表现层(web层)，业务层，持久(数据库)层。 不同层次包名的命名 分层 包名(公司域名倒写) 表现层(web层) com.itheima.web 编写Servlet 业务层(service层) com.itheima.service 编写Service类 持久层(数据库访问层) com.itheima.dao 编写Dao类 JavaBean com.itheima.bean 封装数据 工具类 com.itheima.utils 编写工具类 分层的意义: 解耦：降低层与层之间的耦合性。 可维护性：提高软件的可维护性，对现有的功能进行修改和更新时不会影响原有的功能。 可扩展性：提升软件的可扩展性，添加新的功能的时候不会影响到现有的功能。 可重用性：不同层之间进行功能调用时，相同的功能可以重复使用。 缺点：代码量增多，结构复杂，当新增功能时，需要web、service、dao分别写一次。 但是利大于弊！所以今后的开发全部使用三层架构进行代码编写。 好的代码：低耦合+高内聚 3.小结 模式一：jsp+javabean 模式二：MVC M：model javabean 封装数据 V：view jsp|html 展示数据 C：controller servlet 接收请求，调用业务处理，响应 三层架构： 表现层【web】： com.itheima.web 编写Servlet类 获取请求参数 调用业务处理 响应 业务层【service】：com.itheima.service 编写Service类 处理业务 调用dao 持久层【dao】：com.itheima.dao 编写dao类 操作数据库 案例-完成转账的案例v2一.需求 使用三层架构改写转账案例 二,分析 三,实现 TransferServlet package com.itheima.web; import com.itheima.service.TransferService; import com.itheima.utils.C3P0Utils; import org.apache.commons.dbutils.QueryRunner; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.sql.SQLException; @WebServlet(&quot;/transfer&quot;) public class TransferServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { //0.中文乱码处理 request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); //1.获取请求参数【付款方、收款方、金额】 String from = request.getParameter(&quot;from&quot;); //付款方 String to = request.getParameter(&quot;to&quot;); //收款方 double money = Double.parseDouble(request.getParameter(&quot;money&quot;)); //转账金额 //2.调用业务处理 TransferService transferService = new TransferService(); boolean flag = transferService.transfer(from,to,money); //3.响应 if(flag){ response.getWriter().print(&quot;转账成功！&quot;); }else{ response.getWriter().print(&quot;转账失败！&quot;); } } catch (Exception e) { e.printStackTrace(); response.getWriter().print(&quot;服务器异常！&quot;); } } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } } TransferService package com.itheima.service; import com.itheima.dao.TransferDao; import java.sql.SQLException; public class TransferService { /** * 转账业务 * @param from 付款方 * @param to 收款方 * @param money 转账金额 * @return 转账是否成功 true|false */ public boolean transfer(String from, String to, double money) throws SQLException { //1.处理业务【判断付款方 收款方是否存在 转账金额是否合理 假设一切正常】 //2.调用dao TransferDao transferDao = new TransferDao(); //2.1：付款方钱减少 int rows1 = transferDao.reduceMoney(from,money); //2.2：收款方钱增加 int rows2 = transferDao.addMoney(to,money); //3.根据dao处理结果判断转账是否成功 并返回 if(rows1&gt;0 &amp;&amp; rows2&gt;0){ return true; } return false; } } TransferDao package com.itheima.dao; import com.itheima.utils.C3P0Utils; import org.apache.commons.dbutils.QueryRunner; import java.sql.SQLException; public class TransferDao { /** * 付款方钱减少 * @param from * @param money * @return */ public int reduceMoney(String from, double money) throws SQLException { //1.操作数据库 QueryRunner queryRunner = new QueryRunner(C3P0Utils.getDataSource()); String sql = &quot;update account set money = money-? where name=?&quot;; return queryRunner.update(sql,money,from); } /** * 收款方钱增加 * @param to * @param money * @return */ public int addMoney(String to, double money) throws SQLException { //1.操作数据库 QueryRunner queryRunner = new QueryRunner(C3P0Utils.getDataSource()); String sql = &quot;update account set money = money+? where name=?&quot;; return queryRunner.update(sql,money,to); } } 四.小结 web层 com.itheima.web XxxServlet 获取请求参数 调用业务处理 响应 service com.itheima.service XxxService 处理业务 调用dao dao com.itheima.dao XxxDao 操作数据库 案例-完成转账的案例v3一.需求 当单击提交按钮，付款方向收款方安照输入的金额转账。 使用手动事务进行控制 二,分析1.DBUtils实现事务管理 API 说明 QueryRunner() 创建QueryRunner对象. 手动提交事务时使用 query(connection，String sql, Object[] params, ResultSetHandler rsh) 查询(需要传入Connection) update(connection，String sql, Object… params) 更新 2.思路 三,实现 TransferService package com.itheima.service; import com.itheima.dao.TransferDao; import com.itheima.utils.C3P0Utils; import java.sql.Connection; import java.sql.SQLException; public class TransferService { /** * 转账业务 * @param from 付款方 * @param to 收款方 * @param money 转账金额 * @return 转账是否成功 true|false * 需求：转账包含两个操作：一个钱减少，一个钱增加，只有当钱减少和钱增加两个操作都执行成功时，才表示转账成功，如果有一个失败，则转账失败，付款方和收款方的金额应该不变 * 分析：要将转账的两个操作封装成为一个整体，使用事务 事务的特性：将多个操作作为一个整体执行，要成功，都成功，要失败，都失败 * 事务的使用： * 1.开启事务 ：connection.setAutoCommit(false); * 2.执行操作 :钱减少、钱增加 * 3.事务提交或事务回滚 ：true：connection.commit(); false|exception:connection.rollback(); * 事务使用细节：执行操作所有的connection连接对象要是同一个，如果不是同一个，则不能进行事务控制 * 事务使用的地方： * 事务使用在service层，将多个数据库操作作为一个整体执行。 */ public boolean transfer(String from, String to, double money) throws Exception { /********1.开启手动事务*******/ Connection connection = C3P0Utils.getConnection(); connection.setAutoCommit(false); try { //1.处理业务【判断付款方 收款方是否存在 转账金额是否合理 假设一切正常】 //2.调用dao TransferDao transferDao = new TransferDao(); //2.1：付款方钱减少 int rows1 = transferDao.reduceMoney(connection,from,money); //人为制作异常 用于测试 //int i = 1/0; //2.2：收款方钱增加 int rows2 = transferDao.addMoney(connection,to,money); //3.根据dao处理结果判断转账是否成功 并返回 if(rows1&gt;0 &amp;&amp; rows2&gt;0){ //转账成功 提交事务 connection.commit(); return true; }else{ //转账失败 回滚事务 connection.rollback(); return false; } } catch (SQLException throwables) { throwables.printStackTrace(); //发生异常 回滚事务 connection.rollback(); return false; } } } TransferDao package com.itheima.dao; import com.itheima.utils.C3P0Utils; import org.apache.commons.dbutils.QueryRunner; import java.sql.Connection; import java.sql.SQLException; public class TransferDao { /** * 付款方钱减少 * @param from * @param money * @return */ public int reduceMoney(Connection connection, String from, double money) throws SQLException { //1.操作数据库 //注意：多个操作使用同一个connection时，才能进行事务控制 所以此时创建QueryRunner对象时使用无参构造方法 QueryRunner queryRunner = new QueryRunner(); String sql = &quot;update account set money = money-? where name=?&quot;; return queryRunner.update(connection,sql,money,from); } /** * 收款方钱增加 * @param to * @param money * @return */ public int addMoney(Connection connection, String to, double money) throws SQLException { //1.操作数据库 QueryRunner queryRunner = new QueryRunner(); String sql = &quot;update account set money = money+? where name=?&quot;; return queryRunner.update(connection,sql,money,to); } } 四.小结 事务使用步骤 手动开启事务：connection.setAutoCommit(false); 执行操作：多个操作需要使用同一个连接对象connection 事务提交或事务回滚：connection.commit(); connection.rollback(); 事务使用位置：使用在Service层 通过在Service层获取connection对象 传递到dao层进行使用操作数据库。 案例-完成转账的案例v4一.需求 当单击提交按钮，付款方向收款方安照输入的金额转账。 使用事务进行控制 二,分析1.ThreadLocal​ 在“事务传递参数版”中，我们必须修改方法的参数个数，传递连接对象，才可以完成整个事务操作。如果不传递参数，是否可以完成？在JDK中给我们提供了一个工具类：ThreadLocal，此类可以在一个线程中共享数据。 ​ java.lang.ThreadLocal,该类提供了线程局部 (thread-local) 变量，用于在当前线程中共享数据。ThreadLocal工具类底层就是一个Map，key存放的当前线程，value存放需要共享的数据 //模拟ThreadLocal类 public class ThreadLocal{ private Map&lt;Thread,Object&gt; map = new HashMap&lt;Thread,Object&gt;(); public void set(Connection conn){ map.put(Thread.currentThread(),conn); //以当前线程对象作为key } public Object get(){ return map.get(Thread.currentThread()); //只有当前线程才能取出value数据 } } ThreadLocal:实现在当前线程下共享数据【范围小很多】 类似于ServletContext在当前应用下共享数据【范围大一些】 结论：向ThreadLocal对象中添加的数据只能在当前线程下使用。 2.思路 三,代码 ConnectionManager package com.itheima.utils; import java.sql.Connection; public class ConnectionManager { //使用ThreadLocal工具类在同一个线程中共享数据 private static ThreadLocal&lt;Connection&gt; t = new ThreadLocal&lt;&gt;(); //获取Connection对象 public static Connection getConnection() throws Exception { Connection connection = t.get(); if(connection==null){ connection = C3P0Utils.getConnection(); t.set(connection); } return connection; } } UserService package com.itheima.service; import com.itheima.dao.TransferDao; import com.itheima.utils.C3P0Utils; import com.itheima.utils.ConnectionManager; import java.sql.Connection; import java.sql.SQLException; public class TransferService { /** * 转账业务 * @param from 付款方 * @param to 收款方 * @param money 转账金额 * @return 转账是否成功 true|false */ public boolean transfer(String from, String to, double money) throws Exception { /********1.手动开启事务*******/ Connection connection = ConnectionManager.getConnection(); connection.setAutoCommit(false); try { //1.处理业务【判断付款方 收款方是否存在 转账金额是否合理 假设一切正常】 //2.调用dao TransferDao transferDao = new TransferDao(); //2.1：付款方钱减少 int rows1 = transferDao.reduceMoney(from,money); //人为制作异常 用于测试 //int i = 1/0; //2.2：收款方钱增加 int rows2 = transferDao.addMoney(to,money); //3.根据dao处理结果判断转账是否成功 并返回 if(rows1&gt;0 &amp;&amp; rows2&gt;0){ //转账成功 提交事务 connection.commit(); return true; }else{ //转账失败 回滚事务 connection.rollback(); return false; } } catch (SQLException throwables) { throwables.printStackTrace(); //发生异常 回滚事务 connection.rollback(); return false; } } } UserDao package com.itheima.dao; import com.itheima.utils.C3P0Utils; import com.itheima.utils.ConnectionManager; import org.apache.commons.dbutils.QueryRunner; import java.sql.Connection; import java.sql.SQLException; public class TransferDao { /** * 付款方钱减少 * @param from * @param money * @return */ public int reduceMoney(String from, double money) throws Exception { //1.操作数据库 //注意：多个操作使用同一个connection时，才能进行事务控制 所以此时创建QueryRunner对象时使用无参构造方法 QueryRunner queryRunner = new QueryRunner(); String sql = &quot;update account set money = money-? where name=?&quot;; return queryRunner.update(ConnectionManager.getConnection(),sql,money,from); } /** * 收款方钱增加 * @param to * @param money * @return */ public int addMoney(String to, double money) throws Exception { //1.操作数据库 QueryRunner queryRunner = new QueryRunner(); String sql = &quot;update account set money = money+? where name=?&quot;; return queryRunner.update(ConnectionManager.getConnection(),sql,money,to); } } 四.小结 ThreadLocal：java中一个工具类，用于在同一线程中共享数据。 使用ThreadLocal存储Connection对象在同一线程中共享，这样Service和dao层获取Connection连接对象，就直接从ThreadLocal中拿，得到的就是同一个Connection对象，就可以实现事务控制。 本章小结 EL表达式 概念：用于在jsp页面中获取域对象中存储的数据 目的：简化jsp页面数据获取 语法：${EL表达式} 获取域对象中存储的数据 简单类型数据获取 ：${key} 数组类型数据获取：${key[下标]} list集合数据获取：${key[下标]} 或${key.get(下标)} map集合数据获取：${key[“map的key”]} 或${key.get(“map的key”)} 或者 ${key.map的key} javabean属性值获取：${key.javabean属性名称} 注意： ​ 1.EL获取数据 从作用域范围小的到大的进行查找，找到就停止，找不到返回”” ​ 2.EL获取数据会进行自动类型转换 ​ 3.EL获取key中包含特殊字符的数据 ​ ${requestScope[“key”]} ​ ${key[“map的key”]} 执行运算 +：在这里表示加运算，不进行字符串拼接，如果+号两边有一方无法转为数字类型，则报错 empty： 判断对象是否为null 为null返回true 判断String为null或者”” 如果是返回true 判断list集合为null或长度为0 如果是返回true JSTL标签库 使用步骤 添加jar包到项目 在要使用jstl标签的jsp页面引入jstl标签库 &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; if标签的使用 如果test属性值为true，则执行if标签体中的内容 &lt;c:if test=&quot;el表达式 返回boolean类型的结果&quot;&gt;&lt;/c:if&gt; foreach标签的使用 &lt;c:forEach items=&quot;要遍历的集合|数组&quot; var=“迭代变量”&gt; ${迭代变量} &lt;/c:forEach&gt; 开发模式 MVC开发模式 m：model 模型 javabean 封装数据 v：view 视图 jsp 展示数据 c：controller 控制器 Servlet 接收请求，调用业务处理，给出响应 三层架构 web层 com.itheima.web xxxServlet 获取请求参数 调用业务处理 响应 service层 com.itheima.service xxxService 处理业务 调用dao dao层 com.itheima.dao xxxDao 操作数据库 转账案例 传统方式实现转账案例 三层架构实现转账案例 手动事务控制实现转账 使用ThreadLocal统一管理connection对象 实现事务控制转账 练习： ==传统方式实现转账案例== ==三层架构实现转账案例== 手动事务控制实现转账 使用ThreadLocal JSTL中if和forEach标签的使用 使用EL表达式获取数据 ​","categories":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zhaoshengmu.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://zhaoshengmu.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}]},{"title":"Mybatis","slug":"Mybatis","date":"2022-08-06T02:16:01.000Z","updated":"2022-08-11T14:13:22.681Z","comments":true,"path":"2022/08/06/Mybatis/","link":"","permalink":"https://zhaoshengmu.top/2022/08/06/Mybatis/","excerpt":"","text":"Mybatis练习目标 能够使用映射配置文件实现CRUD操作 能够使用注解实现CRUD操作 1，配置文件实现CRUD 如上图所示产品原型，里面包含了品牌数据的 查询 、按条件查询、添加、删除、批量删除、修改 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表： 查询 查询所有数据 查询详情 条件查询 添加 修改 修改全部字段 修改动态字段 删除 删除一个 批量删除 我们先将必要的环境准备一下。 1.1 环境准备 数据库表（tb_brand）及数据准备 -- 删除tb_brand表 drop table if exists tb_brand; -- 创建tb_brand表 create table tb_brand ( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int ); -- 添加数据 insert into tb_brand (brand_name, company_name, ordered, description, status) values (&#39;三只松鼠&#39;, &#39;三只松鼠股份有限公司&#39;, 5, &#39;好吃不上火&#39;, 0), (&#39;华为&#39;, &#39;华为技术有限公司&#39;, 100, &#39;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#39;, 1), (&#39;小米&#39;, &#39;小米科技有限公司&#39;, 50, &#39;are you ok&#39;, 1); 实体类 Brand 在 com.itheima.pojo 包下创建 Brand 实体类。 public class Brand { // id 主键 private Integer id; // 品牌名称 private String brandName; // 企业名称 private String companyName; // 排序字段 private Integer ordered; // 描述信息 private String description; // 状态：0：禁用 1：启用 private Integer status; //省略 setter and getter。自己写时要补全这部分代码 } 编写测试用例 测试代码需要在 test/java 目录下创建包及测试用例。项目结构如下： 安装 MyBatisX 插件 MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。 主要功能 XML映射配置文件 和 接口方法 间相互跳转 根据接口方法生成 statement 安装方式 点击 file ，选择 settings ，就能看到如下图所示界面 注意：安装完毕后需要重启IDEA 插件效果 红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法，自动生成映射配置文件中的 statement ，如图所示 1.2 查询所有数据 如上图所示就页面上展示的数据，而这些数据需要从数据库进行查询。接下来我们就来讲查询所有数据功能，而实现该功能我们分以下步骤进行实现： 编写接口方法：Mapper接口 参数：无 查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。 结果：List 我们会将查询出来的每一条数据封装成一个 Brand 对象，而多条数据封装多个 Brand 对象，需要将这些对象封装到List集合中返回。 执行方法、测试 1.2.1 编写接口方法在 com.itheima.mapper 包写创建名为 BrandMapper 的接口。并在该接口中定义 List&lt;Brand&gt; selectAll() 方法。 public interface BrandMapper { /** * 查询所有 */ List&lt;Brand&gt; selectAll(); } 1.2.2 编写SQL语句在 reources 下创建 com/itheima/mapper 目录结构，并在该目录下创建名为 BrandMapper.xml 的映射配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.itheima.mapper.BrandMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select * from tb_brand; &lt;/select&gt; &lt;/mapper&gt; 1.2.3 编写测试方法在 MybatisTest 类中编写测试查询所有的方法 @Test public void testSelectAll() throws IOException { //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 List&lt;Brand&gt; brands = brandMapper.selectAll(); System.out.println(brands); //5. 释放资源 sqlSession.close(); } 注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。 执行测试方法结果如下： 从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。为什么这样呢？ 这个问题可以通过两种方式进行解决： 给字段起别名 使用resultMap定义字段和属性的映射关系 1.2.4 起别名解决上述问题从上面结果可以看到 brandName 和 companyName 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在实体类中属性名是 brandName 和 companyName ，而表中的字段名为 brand_name 和 company_name，如下图所示 。那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。 我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。 &lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select id, brand_name as brandName, company_name as companyName, ordered, description, status from tb_brand; &lt;/select&gt; 而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了sql 片段可以提高sql的复用性。 SQL片段： 将需要复用的SQL片段抽取到 sql 标签中 &lt;sql id=&quot;brand_column&quot;&gt; id, brand_name as brandName, company_name as companyName, ordered, description, status &lt;/sql&gt; id属性值是唯一标识，引用时也是通过该值进行引用。 在原sql语句中进行引用 使用 include 标签引用上述的 SQL 片段，而 refid 指定上述 SQL 片段的id值。 &lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select &lt;include refid=&quot;brand_column&quot; /&gt; from tb_brand; &lt;/select&gt; 1.2.5 使用resultMap解决上述问题起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。 那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。 在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系 &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;!-- id：完成主键字段的映射 column：表的列名 property：实体类的属性名 result：完成一般字段的映射 column：表的列名 property：实体类的属性名 --&gt; &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt; &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt; &lt;/resultMap&gt; 注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。 SQL语句正常编写 &lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand; &lt;/select&gt; 1.2.6 小结实体类属性名 和 数据库表列名 不一致，不能自动封装数据 ==起别名：==在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样 可以定义 片段，提升复用性 ==resultMap：==定义 完成不一致的属性名和列名的映射 而我们最终选择使用 resultMap的方式。查询映射配置文件中查询所有的 statement 书写如下： &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;!-- id：完成主键字段的映射 column：表的列名 property：实体类的属性名 result：完成一般字段的映射 column：表的列名 property：实体类的属性名 --&gt; &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt; &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand; &lt;/select&gt; 1.3 查询详情 有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 查看详情 来进行查询，如上图所示。 查看详情功能实现步骤： 编写接口方法：Mapper接口 参数：id 查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。 结果：Brand 根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可 编写SQL语句：SQL映射文件 执行方法、进行测试 1.3.1 编写接口方法在 BrandMapper 接口中定义根据id查询数据的方法 /** * 查看详情：根据Id查询 */ Brand selectById(int id); 1.3.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType &lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = #{id}; &lt;/select&gt; 注意：上述SQL中的 #{id}先这样写，一会我们再详细讲解 1.3.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 @Test public void testSelectById() throws IOException { //接收参数，该id以后需要传递过来 int id = 1; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 Brand brand = brandMapper.selectById(id); System.out.println(brand); //5. 释放资源 sqlSession.close(); } 执行测试方法结果如下： 1.3.4 参数占位符查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 #{id} 最终会被？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。 mybatis提供了两种参数占位符： #{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 PreparedStatement ${} ：拼接SQL。底层使用的是 Statement，会存在SQL注入问题。如下图将 映射配置文件中的 #{} 替换成 ${} 来看效果 &lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = ${id}; &lt;/select&gt; 重新运行查看结果如下： ==注意：==从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符。 1.3.5 parameterType使用对于有参数的mapper接口方法，我们在映射配置文件中应该配置 ParameterType 来指定参数类型。只不过该属性都可以省略。如下图： &lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = ${id}; &lt;/select&gt; 1.3.6 SQL语句中特殊字段处理以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值，如下图 可以看出报错了，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义 转义字符 下图的 &amp;lt; 就是 &lt; 的转义字符。 &lt;![CDATA[内容]]&gt; 1.4 多条件查询 我们经常会遇到如上图所示的多条件查询，将多条件查询的结果展示在下方的数据列表中。而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题 条件表达式 如何连接 条件字段 企业名称 和 品牌名称 需要进行模糊查询，所以条件应该是： 简单的分析后，我们来看功能实现的步骤： 编写接口方法 参数：所有查询条件 结果：List 在映射配置文件中编写SQL语句 编写测试方法并执行 1.4.1 编写接口方法在 BrandMapper 接口中定义多条件查询的方法。 而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现 使用 @Param(&quot;参数名称&quot;) 标记每一个参数，在映射配置文件中就需要使用 #{参数名称} 进行占位 List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName,@Param(&quot;brandName&quot;) String brandName); 将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #{内容} 时，里面的内容必须和实体类属性名保持一致。 List&lt;Brand&gt; selectByCondition(Brand brand); 将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #{内容} 时，里面的内容必须和map集合中键的名称一致。 List&lt;Brand&gt; selectByCondition(Map map); 1.4.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType &lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where status = #{status} and company_name like #{companyName} and brand_name like #{brandName} &lt;/select&gt; 1.4.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 @Test public void testSelectByCondition() throws IOException { //接收参数 int status = 1; String companyName = &quot;华为&quot;; String brandName = &quot;华为&quot;; // 处理参数 companyName = &quot;%&quot; + companyName + &quot;%&quot;; brandName = &quot;%&quot; + brandName + &quot;%&quot;; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 //方式一 ：接口方法参数使用 @Param 方式调用的方法 //List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName); //方式二 ：接口方法参数是 实体类对象 方式调用的方法 //封装对象 /* Brand brand = new Brand(); brand.setStatus(status); brand.setCompanyName(companyName); brand.setBrandName(brandName);*/ //List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand); //方式三 ：接口方法参数是 map集合对象 方式调用的方法 Map map = new HashMap(); map.put(&quot;status&quot; , status); map.put(&quot;companyName&quot;, companyName); map.put(&quot;brandName&quot; , brandName); List&lt;Brand&gt; brands = brandMapper.selectByCondition(map); System.out.println(brands); //5. 释放资源 sqlSession.close(); } 1.4.4 动态SQL上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的 例如用户只输入 当前状态 时，SQL语句就是 select * from tb_brand where status = #{status} 而用户如果只输入企业名称时，SQL语句就是 select * from tb_brand where company_name like #{companName} 而用户如果输入了 当前状态 和 企业名称 时，SQL语句又不一样 select * from tb_brand where status = #{status} and company_name like #{companName} 针对上述的需要，Mybatis对动态SQL有很强大的支撑： if choose (when, otherwise) trim (where, set) foreach 我们先学习 if 标签和 where 标签： if 标签：条件判断 test 属性：逻辑表达式 &lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where &lt;if test=&quot;status != null&quot;&gt; and status = #{status} &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#39;&#39; &quot;&gt; and company_name like #{companyName} &lt;/if&gt; &lt;if test=&quot;brandName != null and brandName != &#39;&#39; &quot;&gt; and brand_name like #{brandName} &lt;/if&gt; &lt;/select&gt; 如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。 执行结果如下： 但是它也存在问题，如果此时给的参数值是 Map map = new HashMap(); // map.put(&quot;status&quot; , status); map.put(&quot;companyName&quot;, companyName); map.put(&quot;brandName&quot; , brandName); 拼接的SQL语句就变成了 select * from tb_brand where and company_name like ? and brand_name like ? 而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决 where 标签 作用： 替换where关键字 会动态的去掉第一个条件前的 and 如果所有的参数没有值则不加where关键字 &lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #{status} &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#39;&#39; &quot;&gt; and company_name like #{companyName} &lt;/if&gt; &lt;if test=&quot;brandName != null and brandName != &#39;&#39; &quot;&gt; and brand_name like #{brandName} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 注意：需要给每个条件前都加上 and 关键字。 1.5 单个条件（动态SQL） 如上图所示，在查询时只能选择 品牌名称、当前状态、企业名称 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 这种需求需要使用到 choose（when，otherwise）标签 实现， 而 choose 标签类似于Java 中的switch语句。 通过一个案例来使用这些标签 1.5.1 编写接口方法在 BrandMapper 接口中定义单条件查询的方法。 /** * 单条件动态查询 * @param brand * @return */ List&lt;Brand&gt; selectByConditionSingle(Brand brand); 1.5.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType &lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;choose&gt;&lt;!--相当于switch--&gt; &lt;when test=&quot;status != null&quot;&gt;&lt;!--相当于case--&gt; status = #{status} &lt;/when&gt; &lt;when test=&quot;companyName != null and companyName != &#39;&#39; &quot;&gt;&lt;!--相当于case--&gt; company_name like #{companyName} &lt;/when&gt; &lt;when test=&quot;brandName != null and brandName != &#39;&#39;&quot;&gt;&lt;!--相当于case--&gt; brand_name like #{brandName} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 1.5.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 @Test public void testSelectByConditionSingle() throws IOException { //接收参数 int status = 1; String companyName = &quot;华为&quot;; String brandName = &quot;华为&quot;; // 处理参数 companyName = &quot;%&quot; + companyName + &quot;%&quot;; brandName = &quot;%&quot; + brandName + &quot;%&quot;; //封装对象 Brand brand = new Brand(); //brand.setStatus(status); brand.setCompanyName(companyName); //brand.setBrandName(brandName); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand); System.out.println(brands); //5. 释放资源 sqlSession.close(); } 执行测试方法结果如下： 1.6 添加数据 如上图是我们平时在添加数据时展示的页面，而我们在该页面输入想要的数据后添加 提交 按钮，就会将这些数据添加到数据库中。接下来我们就来实现添加数据的操作。 编写接口方法 参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 ==自动增长== 生成的。 编写SQL语句 编写测试方法并执行 明确了该功能实现的步骤后，接下来我们进行具体的操作。 1.6.1 编写接口方法在 BrandMapper 接口中定义添加方法。 /** * 添加 */ void add(Brand brand); 1.6.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写添加数据的 statement &lt;insert id=&quot;add&quot;&gt; insert into tb_brand (brand_name, company_name, ordered, description, status) values (#{brandName}, #{companyName}, #{ordered}, #{description}, #{status}); &lt;/insert&gt; 1.6.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 @Test public void testAdd() throws IOException { //接收参数 int status = 1; String companyName = &quot;波导手机&quot;; String brandName = &quot;波导&quot;; String description = &quot;手机中的战斗机&quot;; int ordered = 100; //封装对象 Brand brand = new Brand(); brand.setStatus(status); brand.setCompanyName(companyName); brand.setBrandName(brandName); brand.setDescription(description); brand.setOrdered(ordered); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了 //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.add(brand); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close(); } 执行结果如下： 1.6.4 添加-主键返回在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。 比如：添加订单和订单项，如下图就是京东上的订单 订单数据存储在订单表中，订单项存储在订单项表中。 添加订单数据 添加订单项数据，订单项中需要设置所属订单的id 明白了什么时候 主键返回 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。 我们将上面添加品牌数据的案例中映射配置文件里 statement 进行修改，如下 &lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into tb_brand (brand_name, company_name, ordered, description, status) values (#{brandName}, #{companyName}, #{ordered}, #{description}, #{status}); &lt;/insert&gt; 在 insert 标签上添加如下属性： useGeneratedKeys：是够获取自动增长的主键值。true表示获取 keyProperty ：指定将获取到的主键值封装到哪儿个属性里 1.7 修改 如图所示是修改页面，用户在该页面书写需要修改的数据，点击 提交 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪儿个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据。 接下来我们就具体来实现 1.7.1 编写接口方法在 BrandMapper 接口中定义修改方法。 /** * 修改 */ void update(Brand brand); 上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。 1.7.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写修改数据的 statement。 &lt;update id=&quot;update&quot;&gt; update tb_brand &lt;set&gt; &lt;if test=&quot;brandName != null and brandName != &#39;&#39;&quot;&gt; brand_name = #{brandName}, &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#39;&#39;&quot;&gt; company_name = #{companyName}, &lt;/if&gt; &lt;if test=&quot;ordered != null&quot;&gt; ordered = #{ordered}, &lt;/if&gt; &lt;if test=&quot;description != null and description != &#39;&#39;&quot;&gt; description = #{description}, &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; status = #{status} &lt;/if&gt; &lt;/set&gt; where id = #{id}; &lt;/update&gt; set 标签可以用于动态包含需要更新的列，忽略其它不更新的列。 1.7.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 @Test public void testUpdate() throws IOException { //接收参数 int status = 0; String companyName = &quot;波导手机&quot;; String brandName = &quot;波导&quot;; String description = &quot;波导手机,手机中的战斗机&quot;; int ordered = 200; int id = 6; //封装对象 Brand brand = new Brand(); brand.setStatus(status); // brand.setCompanyName(companyName); // brand.setBrandName(brandName); // brand.setDescription(description); // brand.setOrdered(ordered); brand.setId(id); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 int count = brandMapper.update(brand); System.out.println(count); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close(); } 执行测试方法结果如下： 从结果中SQL语句可以看出，只修改了 status 字段值，因为我们给的数据中只给Brand实体对象的 status 属性设置值了。这就是 set 标签的作用。 1.8 删除一行数据 如上图所示，每行数据后面都有一个 删除 按钮，当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。 接下来就来实现该功能。 1.8.1 编写接口方法在 BrandMapper 接口中定义根据id删除方法。 /** * 根据id删除 */ void deleteById(int id); 1.8.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写删除一行数据的 statement &lt;delete id=&quot;deleteById&quot;&gt; delete from tb_brand where id = #{id}; &lt;/delete&gt; 1.8.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 @Test public void testDeleteById() throws IOException { //接收参数 int id = 6; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.deleteById(id); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close(); } 运行过程只要没报错，直接到数据库查询数据是否还存在。 1.9 批量删除 如上图所示，用户可以选择多条数据，然后点击上面的 删除 按钮，就会删除数据库中对应的多行数据。 1.9.1 编写接口方法在 BrandMapper 接口中定义删除多行数据的方法。 /** * 批量删除 */ void deleteByIds(int[] ids); 参数是一个数组，数组中存储的是多条数据的id 1.9.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写删除多条数据的 statement。 编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 foreach 标签供我们使用 foreach 标签 用来迭代任何可迭代的对象（如数组，集合）。 collection 属性： mybatis会将数组参数，封装为一个Map集合。 默认：array = 数组 使用@Param注解改变map集合的默认key的名称 item 属性：本次迭代获取到的元素。 separator 属性：集合项迭代之间的分隔符。foreach 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。 open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次 close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次 &lt;delete id=&quot;deleteByIds&quot;&gt; delete from tb_brand where id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #{id} &lt;/foreach&gt; ; &lt;/delete&gt; 假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是： delete from tb_brand where id in (1,2,3); 1.9.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 @Test public void testDeleteByIds() throws IOException { //接收参数 int[] ids = {5,7,8}; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.deleteByIds(ids); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close(); } 1.10 Mybatis参数传递Mybatis 接口方法中可以接收各种各样的参数，如下： 多个参数 单个参数：单个参数又可以是如下类型 POJO 类型 Map 集合类型 Collection 集合类型 List 集合类型 Array 类型 其他类型 1.10.1 多个参数如下面的代码，就是接收两个参数，而接收多个参数需要使用 @Param 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。 User select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); &lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#{username} and password=#{password} &lt;/select&gt; 我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 @Param 注解时有以下命名规则： 以 arg 开头 ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如： map.put(“arg0”，参数值1); map.put(“arg1”，参数值2); 以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如： map.put(“param1”，参数值1); map.put(“param2”，参数值2); 代码验证： 在 UserMapper 接口中定义如下方法 User select(String username,String password); 在 UserMapper.xml 映射配置文件中定义SQL &lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#{arg0} and password=#{arg1} &lt;/select&gt; 或者 &lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#{param1} and password=#{param2} &lt;/select&gt; 运行代码结果如下 在映射配合文件的SQL语句中使用用 arg 开头的和 param 书写，代码的可读性会变的特别差，此时可以使用 @Param 注解。 在接口方法参数上使用 @Param 注解，Mybatis 会将 arg 开头的键名替换为对应注解的属性值。 代码验证： 在 UserMapper 接口中定义如下方法，在 username 参数前加上 @Param 注解 User select(@Param(&quot;username&quot;) String username, String password); Mybatis 在封装 Map 集合时，键名就会变成如下： map.put(“username”，参数值1); map.put(“arg1”，参数值2); map.put(“param1”，参数值1); map.put(“param2”，参数值2); 在 UserMapper.xml 映射配置文件中定义SQL &lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#{username} and password=#{param2} &lt;/select&gt; 运行程序结果没有报错。而如果将 #{} 中的 username 还是写成 arg0 &lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#{arg0} and password=#{param2} &lt;/select&gt; 运行程序则可以看到错误 ==结论：以后接口参数是多个时，在每个参数上都使用 @Param 注解。这样代码的可读性更高。== 1.10.2 单个参数 POJO 类型 直接使用。要求 属性名 和 参数占位符名称 一致 Map 集合类型 直接使用。要求 map集合的键名 和 参数占位符名称 一致 Collection 集合类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，collection集合); map.put(“collection”，collection集合; ==可以使用 @Param 注解替换map集合中默认的 arg 键名。== List 集合类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，list集合); map.put(“collection”，list集合); map.put(“list”，list集合); ==可以使用 @Param 注解替换map集合中默认的 arg 键名。== Array 类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，数组); map.put(“array”，数组); ==可以使用 @Param 注解替换map集合中默认的 arg 键名。== 其他类型 比如int类型，参数占位符名称 叫什么都可以。尽量做到见名知意 2，注解实现CRUD使用注解开发会比配置文件开发更加方便。如下就是使用注解进行开发 @Select(value = &quot;select * from tb_user where id = #{id}&quot;) public User select(int id); ==注意：== 注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 statement Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下： 查询 ：@Select 添加 ：@Insert 修改 ：@Update 删除 ：@Delete 接下来我们做一个案例来使用 Mybatis 的注解开发 代码实现： 将之前案例中 UserMapper.xml 中的 根据id查询数据 的 statement 注释掉 在 UserMapper 接口的 selectById 方法上添加注解 运行测试程序也能正常查询到数据 我们课程上只演示这一个查询的注解开发，其他的同学们下来可以自己实现，都是比较简单。 ==注意：==在官方文档中 入门 中有这样的一段话： 所以，==注解完成简单功能，配置文件完成复杂功能。== 而我们之前写的动态 SQL 就是复杂的功能，如果用注解使用的话，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下： 上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。","categories":[{"name":"资源","slug":"资源","permalink":"https://zhaoshengmu.top/categories/资源/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zhaoshengmu.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://zhaoshengmu.top/tags/悦读/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"https://zhaoshengmu.top/categories/资源/"}]},{"title":"关于博客","slug":"关于博客","date":"2022-08-06T00:08:26.000Z","updated":"2022-08-11T14:13:22.686Z","comments":true,"path":"2022/08/06/关于博客/","link":"","permalink":"https://zhaoshengmu.top/2022/08/06/关于博客/","excerpt":"","text":"评论区​ 评论区现在已经可以正常使用了，留言板功能也正常了，这玩意评论是不需要那些信息的，都是匿名的，信息随便填或者不填都可以。 音乐​ 左下角有音乐播放的按钮，里面就几首歌，比较单一，如果有想加上去的歌可以在评论区或者留言板说明，文章的歌曲也可以在下面留言更换歌曲。 建议感觉这个博客用手机登录的效果不是很好，它本身其实就是用来电脑登录的，只是适配了移动端，所以用电脑登录的感官可能更好点。（ps电脑登录的话右下角的人物会随着鼠标的移动而改变视线，手机上登录会随着手机触摸方向的改变而改变视线）","categories":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zhaoshengmu.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://zhaoshengmu.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhaoshengmu.top/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2022-08-04T12:16:01.000Z","updated":"2022-08-11T08:04:18.485Z","comments":true,"path":"2022/08/04/Hexo-Theme-Sakura/","link":"","permalink":"https://zhaoshengmu.top/2022/08/04/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 朝生暮的小屋~ subtitle: description: 站点简介 keywords: author: 朝生暮 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://zhaoshengmu.top # 站点介绍（或者说是个人签名）【改】 description: 朝闻道，夕可死矣 # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https\\:\\/\\/cdn\\.statically\\.io\\/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true #v_appId: MIyrUwE8znnXEAPY3V0CA3xX-MdYXbMMI v_appId: Staaz3FNbHAxBLecD9DFjhfu-gzGzoHsz #v_appKey: BjqrvOtagtUwwojIAxcKSmFP v_appKey: bfvLFp8vPRNo3A3Dt11mlo4C serverURLs: https://miyruwe8.api.lncldglobal.com # https://MIyrUwE8.api.lncldglobal.com 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2022-8-10 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://img-1313111331.cos.ap-nanjing.myqcloud.com/webImage/hexoWeb/202208061255248.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: true date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"转载","slug":"转载","permalink":"https://zhaoshengmu.top/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zhaoshengmu.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://zhaoshengmu.top/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"https://zhaoshengmu.top/categories/转载/"}]},{"title":"搭建博客的初衷","slug":"搭建这个博客的初衷","date":"2022-08-04T07:16:01.000Z","updated":"2022-08-11T14:13:22.698Z","comments":true,"path":"2022/08/04/搭建这个博客的初衷/","link":"","permalink":"https://zhaoshengmu.top/2022/08/04/搭建这个博客的初衷/","excerpt":"","text":"//快速排序 初衷​ 其实一开始就只是学了点html css js 后想找个项目练练手,然后太小的项目看不上,太大的项目搞不定,然后刚好看到一个在我看来挺厉害的网站作者介绍搭建网站的步骤,我一看这貌似也不难,租个域名搞个服务器再去gayhub上copy一套模板,这一套走下来不就有了个网站吗.刚好那个大佬介绍的是一个导航类资源网站，我寻思着刚好我那么多收藏夹需要整理，正好用这个网站整理了，然后就说干就干了。​ 当时也清楚自己几斤几两，虽然看着js html css简单但确实也不是自己想搞就能搞定的，所以去搞了套模板，那套模板确实挺简单，不过代码行数看着挺唬人，四五千行，然后我一看，特么绝大部分都是重复的用来控制不同网站的内容，但是我真的有点烦这样改下去，因为太特么机械化了，一点水平没有，所以我就改了十来个就不想改了，决定搞点别的。​ 当时的想法是看到别人的网站有一个音乐播放器，这玩意我一看我寻思着这不错啊，盘它！然后去网上找了相关代码，准备给我原来的代码来个无创手术。（具体的GIF版本的播放器如下） ​ 过程不讲了，反正由于我特么知识还没学完导致有些地方卡的我神魂颠倒。不过还好最终是搞定了，虽然说吧颜色不怎么搭配，我那个网站是黑色调， 虽然这个播放器调颜色很方便但是我属实不相信自己的审美，于是乎，就这样过去了，反正功能实现了。 ​ 再然后，我有点看不上这种网站了，毕竟是静态网站，每次都得改动源码才能改变界面，改变完还得在上传一下才能在服务器同步，麻烦，我当时想搞一个博客，无他，博客的颜值让我一眼万年了。当时我搜了下，现阶段比较牛皮的网页框架有一个开源的WordPress，还有一个hexo很美观，当时我一开始是想搞个hexo的，毕竟颜值可以，但是发现这玩意没后台管理功能，我寻思着那算了直接一步到位用WordPress吧毕竟美国白宫的官网都是用它搭建的，结果这玩意我折腾了一天博客可以说是搞定了，但是由于我之前的导航网页的服务器是白嫖的netlify的，但是它不能搞WordPress这种大型的网页，所以我又去白嫖了阿里的服务器一个月，但是这种网络备案需要三个月以上的服务器，所以我是没办法备案了，当时还想去白嫖谷歌微软这种的一年的试用，但是奈何需要国外信用卡，虽然说国内有的也支持但是我也没有所以只能放弃。 ​ 所以我当时虽然搞定了具体布局但是心里也不太想搞下去了，因为没必要，搞上去也就只是能让别人通过互联网能看到，而且他这个确实没什么技术含量，基本都是图形化搭建过程，我需要的是对源码的掌握，所以我又转头朝着hexo走去，因为hexo是从源码开始的。 （图为WordPress博客，但是截图截得有点问题但是现在网页已经关了再打开还要密码就算了将就着看看，中间没有那个灰色线的） ​ 所以最终版本大概就是我现在hexo了，反正几经波折，由于域名比较便宜所以买了俩域名，刚好一个导航网站一个hexo，以后也不一定在上面发表文章，毕竟笔记用notion写是真的挺方便的，上传个文章还得打开源码改好再上传，有些麻烦了属实是。 结语 这个网站还是有很多待完善的地方，比如留言和评论功能，但是这两个在国内需要实名才能留言，比较麻烦，就暂时没搞，（已经搞了可以评论了）哦对左下角有一个音乐播放功能需要点击弹窗才会弹出，默认是隐藏的，不过音乐不是我选的，反正就这样吧，以后有空再弄。还有想搞一个live2d看板娘的，但是不知道ejs文件怎么搞。总结来说就是花了两三天结果也没学会什么，头发倒是掉了不少","categories":[{"name":"生活","slug":"生活","permalink":"https://zhaoshengmu.top/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zhaoshengmu.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://zhaoshengmu.top/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://zhaoshengmu.top/categories/生活/"}]}]}